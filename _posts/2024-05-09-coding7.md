---
layout: single
title:  "[JAVA] [코딩테스트] 브루트 포스 - BOJ/2839번"
categories: 코딩테스트






---

JAVA로 코딩테스트 공부 시작.
{: .notice--danger}

### 문제

상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.

상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.

상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)

### 출력

상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.

### 예제 입력 1

```
18
```

### 예제 출력 1

```
4
```

### 예제 입력 2

```
4
```

### 예제 출력 2

```
-1
```

### 예제 입력 3

```
6
```

### 예제 출력 3

```
2
```

### 예제 입력 4

```
9
```

### 예제 출력 4

```
3
```



<br/>

<hr/>

<br/>

### 💡 풀이

<script src="https://gist.github.com/Hanseung2/a7b7d43c63ccd8f5e668e9424c6c4c7c.js"></script>

> Brute - force란 완전탐색 알고리즘이라고도 하며, 가능한 모든 경우의 수를 모두 탐색하여 100% 확률로 정답을 출력하는 알고리즘이다. 
>
> 보통 반복문을 통해 무식하게 정답을 찾으며 구현하기 쉽다는 장점과 실행시간이 매우 오래 걸린다는 단점이 있다.
>
> 브루트 포스의 종류를 선형과 비선형 구조로 나눌 수 있는데, 
>
> 선형 구조 : 순차 탐색
>
> 비선형 구조 : 백트래킹, DFS, BFS
>
> 가 있다.

<br/>

👉 여기서 부턴 학과 "알고리즘" 시간에 배웠던 종류들이 등장해서 내가 풀고 난 후, 사람들의 풀이를 보면서 공부했다.

내 생각 : 3kg 과 5kg 봉지를 사용하여 가장 적게 쓰는 봉지의 수를 구하는 방식인데, 더 큰 봉지를 사용해야 총 봉지 갯수가 적어지므로 처음 입력받았을 때 3으로 나눠지는 경우만 제외하면 `while` 문에서 5를 계속 빼준다음에 3으로 나눠 갯수를 list에 넣은다음 최솟값을 구하는 방식.

<br/>

<hr/>

<br/>

사람들의 풀이 : DP와 Greedy 방식으로 나눠져 있었다.

1️⃣ <span style="background-color:#fff5b1">DP (Dynamic Programming) </span>: 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장해 다시 큰 문제를 해결할 때 사용하는 문제해결 패러다임이다. 예를 들어, 피보나치 수열을 재귀적으로 계산할시에 `f(n) = f(n-1) + f(n-2)` 가 되는데 그럼 특정 값을 구하기 위해서 같은 값이 필요한 경우가 매우 많다. 이런 값을 저장해서 사용하게 되면 시간 복잡도를 개선할 수 있다.

 따라서, 위의 설탕 문제를 풀이하면

```c
dp[i] = min(dp[i-3] + 1, dp[i-5] +1)
```

i kg은 이전에 계산한 (i - 3) kg 과 (i - 5) kg 중 작은 것에 1을 더한 값이 되는 것을 이용한다.

<br/>

2️⃣ <span style="background-color:#fff5b1">Greedy (탐욕법)</span> : 최적의 값을 구하는 것으로 "이 순간에서 최적이라고 생각되는 것을 선택" 해 나가는 방식을 택해 최종적인 결과를 출력하는 알고리즘이다. 

따라서, 위의 설탕 문제를 풀이하면

> 내 생각과 비슷하게 5kg 보다 3kg으로 채우는 것이 최소 봉지 갯수를 구하는데 불리하다.
> 따라서, 5kg 으로 나눠지지 않을시에만 3kg 봉지를 사용하면 된다.



💡 어떻게 보면, Greedy 방식과 내 생각이 비슷했는데 차이점이 있다면 나는 모든 경우의 수를 List에 저장해 최솟값을 찾는 반면, Greedy 방식에서는 5로 나눠지면 최적이므로 3kg 씩 빼다가 5로 나눠지는 시점에서 반복문을 바로 종료해 시간 복잡도를 개선했다. 조금만 더 생각하면 알 수 있는 사실